"I have used all OOPS concepts extensively in my framework. Encapsulation in Page Objects and service layers, 
Abstraction using BasePage and BaseTest, Inheritance to reuse setup and common behavior, Polymorphism for browser, 
reporter and environment strategies, and Interfaces to enforce contracts between service layers. 
This makes the framework modular, scalable, and easy to maintain."

ğŸ—ï¸ Real Framework Mapping (VERY IMP)
OOPS Concept	Where in Framework
Encapsulation	Page Objects, Services, Utils
Abstraction	BasePage, BaseTest, Interfaces
Inheritance	BasePage â†’ Pages, BaseTest â†’ Tests
Polymorphism	Browser, Reporter, Env, Auth
Interface	API layers, Drivers, Strategy
ğŸ† Perfect Interview Answer (You Can Say This)



âœ… 1. Encapsulation â€“ Hiding implementation details
ğŸ“Œ Where used:
Page Objects
API Client classes
Service classes
Core utilities (DriverManager, ConfigManager)

ğŸ¯ Why:

Test should not know HOW things are done, only WHAT is done.

ğŸ”¹ Example (Playwright Page Object)
class LoginPage {
  private page: Page;

  constructor(page: Page) {
    this.page = page;
  }

  async login(username: string, password: string) {
    await this.page.fill("#username", username);
    await this.page.fill("#password", password);
    await this.page.click("#loginBtn");
  }
}

âœ… Test uses:
await loginPage.login("admin", "1234");


Test does not care about locators or steps â†’ Encapsulation achieved

âœ… 2. Abstraction â€“ Exposing only what is needed
ğŸ“Œ Where used:

ğŸ”¹ Example: BasePage
abstract class BasePage {
  protected page: Page;

  constructor(page: Page) {
    this.page = page;
  }

  async click(selector: string) {
    await this.page.click(selector);
  }

  async type(selector: string, text: string) {
    await this.page.fill(selector, text);
  }
}

ğŸ”¹ LoginPage extends it:
class LoginPage extends BasePage {
  async login(user: string, pass: string) {
    await this.type("#username", user);
    await this.type("#password", pass);
    await this.click("#login");
  }
}


Tests never see Playwright directly â†’ Abstraction

âœ… 3. Inheritance â€“ Reusing common behavior
ğŸ“Œ Where used:

BaseTest â†’ All tests extend it

BasePage â†’ All pages extend it

BaseAPI â†’ All services extend it

ğŸ”¹ Example:
class BaseTest {
  protected page: Page;

  async setup() {
    this.page = await browser.newPage();
  }
}

ğŸ”¹ Test class:
class LoginTest extends BaseTest {
  async testLogin() {
    const loginPage = new LoginPage(this.page);
    await loginPage.login("admin", "1234");
  }
}


Browser setup reused â†’ Inheritance

âœ… 4. Polymorphism â€“ Same method, different behavior
ğŸ“Œ Where used:


ğŸ”¹ Example: Reporter Interface
interface Reporter {
  log(result: string): void;
}

ğŸ”¹ Implementations:
class AllureReporter implements Reporter {
  log(result: string) { console.log("Allure: " + result); }
}

class ExtentReporter implements Reporter {
  log(result: string) { console.log("Extent: " + result); }
}

ğŸ”¹ Framework uses:
function getReporter(): Reporter {
  return new AllureReporter(); // or ExtentReporter
}


Same interface, different behavior â†’ Polymorphism

âœ… 5. Interface â€“ Contract enforcement
ğŸ“Œ Where used:

API Clients

Service layers

Drivers

Reporters

Environment handlers

ğŸ”¹ Example:
interface PaymentService {
  createPayment(amount: number): Promise<Response>;
}

class StripePayment implements PaymentService {
  async createPayment(amount: number) { ... }
}

class PaypalPayment implements PaymentService {
  async createPayment(amount: number) { ... }
}


Test does not care which payment system â†’ Loose coupling



