                 ▲
                 |    UI / End-to-End Tests (~10%)
                 |    - Functional UI Tests
                 |    - Cross-browser Tests
                 |    - Accessibility Testing
                 |    - User Journey / Workflow Tests
                 |    - Visual Regression
     ------------------------------
                 |    API / Integration Tests (~20%)
                 |    - Contract Testing
                 |    - Component/Service Testing
                 |    - Database Integration Tests
                 |    - Performance (at service level)
                 |    - Security API Tests (Auth, OAuth2)
     ------------------------------------------
                 |    Unit Tests (~70%)
                 |    - Function/Class Tests
                 |    - Boundary Value Tests
                 |    - Data Validation
                 |    - Error Handling
                 |    - Static Analysis / Linters
     ------------------------------------------
                 |    Base / Foundation
                 |    - CI/CD Checks
                 |    - Code Quality (Sonar, PMD)
                 |    - Build Verification
                 ▼


Is your testing team (or an individual tester) spending far too much time waiting for their test suites
to complete running?
If the answer is yes, chances are that this particular team or tester has not implemented the testing pyramid.
 And they should.

Table of Contents
What is Testing Pyramid?
Level 1 – Unit Tests
Level 2 – Integration Tests
Level 3 – End-to-End Tests
Why should Agile Teams use the Testing Pyramid?
What is Testing Pyramid?
Testing Pyramid is a framework that can help both developers and QAs create high-quality software.
 It reduces the time required for developers to identify if a change they introduced breaks the code.
  It can also be helpful in building a more reliable test suite.
This test automation pyramid operates at three levels:

Unit tests
Integration tests
End-to-End tests

Level 1 – Unit Tests
Unit tests form the base of the testing pyramid. They test individual components or functionalities to validate
that it works as expected in isolated conditions. It is important to run a number of scenarios in unit tests –
happy path, error handling, etc.
Since this is the largest subset, the unit test suite must be written to run as quickly as possible.
 Keep in mind that the number of unit tests will increase as more features are added. This test suite needs
 to be run every time a new feature is added. Consequently, developers receive immediate feedback on whether
 individual features are working as they are meant to.
Needless to say, a fast-running unit test suite encourages devs to run it as often as possible.
A good way to build a robust unit test suite is to practice test-driven development (TDD).
Since TDD requires a test to be written before any code, the code ends up being simpler, clearer and bug-free.

To understand how TDD works and its difference with BDD (Business-Driven Development) and ATDD,
 refer to this article on BDD vs TDD.

Level 2 – Integration Tests
Unit tests verify small pieces of a codebase. However, in order to test how this code interacts with other code
 (that form the entire software), integration tests need to be run. Essentially, these are tests that validate
 the interaction of a piece of code with external components. These components can range from databases,
 external services (APIs) and the like.

Integration tests are the second layer of the test automation pyramid. This means that it should not be run
 as frequently as unit tests. Fundamentally, they test how a feature communicates with external dependencies.
 Whether it is a call to a database or web service, the software needs to communicate effectively and retrieve
  the right information to function as expected.

Remember that since integration tests involve interaction with external services, they will run slower than
unit tests. They also require a preproduction environment in which to run.

Level 3 – End-to-End Tests
At the top of the pyramid are the end-to-end tests. These ensure that the entire application is functioning as
required. End-to-end tests do exactly what the name suggests: test that the application is working flawlessly
 from start to finish.

When running these tests, it is important to imagine the user’s perspective. How would an actual user interact
with the app? How can tests be written to replicate that interaction?

End-to-end tests are at the top of the testing pyramid because they usually take the longest to run.
They can also be fragile since they have to test a large variety of user scenarios. Like integration tests,
 these tests may also require the app to communicate with external dependencies, thus adding to possible
 bottlenecks in completion.

Why should Agile Teams use the Testing Pyramid?
Using the test automation pyramid is especially advantageous for agile teams:

Agile processes emphasize speed and efficacy. The testing pyramid offers by streamlining the testing process.
 With a clear progression and logic introduced to the testing pipeline, work gets done faster.
  Since the pyramid is built to run the easiest tests at the beginning, testers manage time better,
   get better results and essentially make life easier for everyone involved.
The pyramid provides testers with the right priorities. If test scripts are written with a greater focus on the
 UI, then chances are that core business logic and back-end functionality is not sufficiently verified.
 This affects product quality and leads to more work for the team. Also, since TAT (turn around time) of UI
 tests is high, it leads to lower test coverage overall. By implementing the pyramid, such situations are
  completely avoided.
In automated testing, tools and frameworks like Selenium execute scripted tests on a software application or
component to ensure it is working as expected. Its entire objective is to reduce human effort and oversight.
 But for a machine to yield the right results, it must be given the right direction.

The test automation pyramid strives to do this by organizing and structuring the test cycle.
 This streamlines the entire processes, brings efficient time management into the picture and gives testers a
  time-tested blueprint to shape their projects.
